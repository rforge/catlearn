## Run minimization
shin92exalcove_opt <- function(params = c(2, 1, .25, .75),
                               recompute = FALSE,
                               trace = 0) {

    ##  Define objective function to minimize
    .alcove.shin92 <- function(params) {
        out <- shin92exalcove(params)
        ret <- ssecl(out$c2p,catlearn::shin92$c2acc)
        return(ret)
    }

    ## Note use of 'catlearn::shin92' rather than just 'shin92' This
    ## is to fix an issue that would otherwise occur during the
    ## building of the package. For any code that will end up in
    ## package, always use the 'catlearn::' preface when referring to
    ## CIRP in the catlearn package.
    
    ## Set level of output verbosity
    ctrl <- list(trace=trace)
    
    ## Set bounds for optimzation
    lb <- c(0.001,0.001,0.001,0.001) # Lower bounds
    ub <- c(20,5,.90,.90)            # Upper bounds

    if(recompute) {
        ## Run optimzation
        names(params) <- c('c','phi','la','lw')
        result <- optim(params, .alcove.shin92, method = "L-BFGS-B",
                        lower = lb, upper = ub, control = ctrl)
    } else {
        ## Set result from stored copy
        ## Note: This can be generated by: dput(result)
        result <- structure(
            list(
                par = structure(
                    c(2.16500692601153, 0.636557148593828, 
                      0.0985741221287437, 0.9),
                    .Names = c("c", "phi","la", "lw")),
                value = 0.262937001899411,
                counts = structure(
                    c(74L, 74L),
                    .Names = c("function", "gradient")),
                convergence = 0L,
                message =
                    "CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"),
            .Names = c("par", "value", "counts", "convergence",
                       "message")
        )
    }
    
    return(result)
}


