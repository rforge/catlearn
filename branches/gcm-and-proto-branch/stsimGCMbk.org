* Overall impressions

This is quite impressive. In particular, I liked the use of 'try'
functions. You obviously know some stuff about coding :-)

* Code optimization

I notice you use loops quite a lot. Vectorization of code is much
faster than loops in R. There should be almost nothing in GCM you need
to use a loop for because GCM is not dynamic (i.e. results of
calculation N do not depend on results of calculation N-1). 

Whether you bother switching to vectorization or not depends a bit on
whether you intend to convert the code to C++ at a later date (Rcpp
interlinks R and C++ well). If you do, it may be easier to just keep
the loops for now. C++ is much faster than even vectorized R code.

* Separation of documentation and code

Documentation of a function occurs in a .Rd file, not the source
code. Some developers do use roxygen to automatically generate their
Rd file from their documentation comments, but this practice is not
widely used in catlearn.

Of course, your code should still be commented on a line-by-line basis
to help understand what each line does, but the big block of text at
the beginning of your file needs to be an a .Rd file. I've hacked one
together for you.

* Cross compatibility for static models

Given the slp schema was written with stateful (adaptive) models
(e.g. ALCOVE) in mind, there's an open question about how best to
represent non-stateful (static) models (e.g. GCM) within catlearn. GCM
is non-stateful in the sense that none of the parameters passed to it
change as a result of its operation. This contrasts to e.g. ALCOVE
where the attentional weights at the end of the simulation are
different to those at the beginning.

There are two aspects coming up with a schema for this ... what to
pass to the function and what it should return, covered below.

I also think it would make sense to retain the 'slp' prefix for models
that are stateful. Let's call this function:

stsimGCM

with the prefix meaning 'static simulation'

** What arguments should be passed?

Personally, I would have gone for keeping the 'tr' array of slpALCOVE
and using the 'ctrl' column to specify whether the row was placing an
exemplar to memory (ctrl = 0) or presenting a test item (ctrl =
2). Category membership of the exemplars could be set using the 't1',
't2', etc columns.

As long as the ctrl = 0 rows came before the ctrl = 2 rows, the order
of presentation would of course not matter.

Why would I have done this? Cross-compatibilty.

Because then slpGCM and slpALCOVE could use many of the same
functions - in particular things like nosof94train. If slpGCM had this
sort of structure, one could just set training and test blocks to 1 in
nosof94train and use it to create the tr array for slpGCM.

In contrast, as things stand, one would have to write a bit of glue
code to convert the output of nosof94train into something that could
be used in slpGCM. This makes catlearn a little bit less modular, and
a little bit harder to use for broad model comparisons.

I haven't changed the code, but it's something to think about.

** What should be returned?

The slp schema only returns those parameters that could have changed
as a result of the simulation. In a static model, nothing could have
changed so it should not return any parameters (just the results).

I have changed this.


* catlearn format style
Bit tedious this, but it helps in open-source projects if everyone
uses the same line length, comments style, indentation etc. catlearn
is tab indented, 80 char max line width, spaces between most operators
and uses ## for comments that have their own line. For readability,
only the very simplest expressions should omit {}
* Version control
Don't call functions things like '_draft'. The point of version
control software (svn, git) is that you use the same names for all
versions of the code.
* Separation of code and unit tests
The code you have under 'examples' have the makings of what we refer
to in the catlearn package as unit tests. Unit tests run functions and
know what output is expected.
* Visible and invisible functions
In an R package, the typical user will only expect to be able to access
your top-level function. The functions this in turns call should be
hidden. You do this by prepending a period. I've done this in your
code. This is also important because every non-hidden function
requires a .Rd file in a R package.
