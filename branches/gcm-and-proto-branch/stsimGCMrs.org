Notes written to Rene S on code contributed to catlearn for GCM
simulations (now called stsimGCMrs)

* Overall impressions

This is quite impressive, well done! You obviously know some stuff
about coding :-)
--- Thank you very much! :) 

* Code optimization

I notice you use loops quite a lot. Vectorization of code is much
faster than loops in R. There should be almost nothing in GCM you need
to use a loop for because GCM is not dynamic. 

--- Halfway done. ('for' loops changed into 'apply' functions, 
in the internet it is said that they at least partially vectorize...
and the functions already became faster. 
I am not yet familiar with vectorization,
as well as C++.)

Whether you bother switching to vectorization or not depends a bit on
whether you intend to convert the code to C++ at a later date (Rcpp
interlinks R and C++ well). If you do, it may be easier to just keep
the loops for now. C++ is much faster than even vectorized R code.

* Separation of documentation and code

For an R package, documentation of a function occurs in a .Rd file,
not the source code. Some developers do use roxygen to automatically
generate their Rd file from their documentation comments, but this
is rare.

Of course, your code should still be commented on a line-by-line basis
to help understand what each line does, but the big block of text at
the beginning of your file needs to be an a .Rd file. 

I've hacked one together for you - you'll find it in the man directory.

--- Thanks, already changed it a bit. I stick to it the future.

* Cross compatibility for static models

Given the slp schema was written with stateful (adaptive) models
(e.g. ALCOVE) in mind, there's an open question about how best to
represent non-stateful (static) models (e.g. GCM) within catlearn. GCM
is non-stateful in the sense that none of the parameters passed to it
change as a result of its operation. This contrasts to e.g. ALCOVE
where the attentional weights at the end of the simulation are
different to those at the beginning.

There are two aspects coming up with a schema for this ... what to
pass to the function and what it should return, covered below.

I also think it would make sense to retain the 'slp' prefix for models
that are stateful. Let's call this function:

stsimGCMrs

with the prefix meaning 'static simulation'

the suffix 'rs' is there because Minda's lab is also working on a GCM
implementation and we need a way of keeping the code bases distinct
for now (when it comes to release, we'll need to merge, or pick one,
or something).

--- Okay. 

** What arguments should be passed?

You've decided to drop the 'tr' array of models like slpALCOVE and
pass everything in st. I guess this is not unreasonable given the
non-dynamic nature of GCM.

I wonder whether, at some point, it might be worth editing then
...train functions (e.g. nosof94train) such that there's an option to
output in this kind of format for key datasets?

--- I will check this, first thought is: definitely possible
without major changes.

** What should be returned?

The slp schema only returns those parameters that could have changed
as a result of the simulation. In a static model, nothing could have
changed so for consistency it should probably not return any
parameters (just the results).

I have changed this in your code.

--- Alright. As you mentioned this, I also added an output for the summed
similarities between the test items and the exemplars from each category,
in case someone wants to focus on similarity judgments.


* catlearn format style

Bit tedious this, but it helps in open-source projects if everyone
uses the same line length, comments style, indentation etc. catlearn
is tab indented, 80 char max line width, spaces between most operators
and uses ## for comments that have their own line. For readability,
only the very simplest expressions should omit {}                        

--- Can do this :)

* Version control

Don't call functions things like '_draft'. The point of version
control software (svn, git) is that you use the same names for all
versions of the code.

--- Check.

* Separation of code and unit tests

The code you have under 'examples' have the makings of what we refer
to in the catlearn package as unit tests. Unit tests run functions and
know what output is expected. I've built a unit test for this you'll
find in the gcm-and-proto branch. 

I've also used the examples as part of the Rd file. This provides
another check on the package, as R refuses to compile a package if the
code in the examples section throws an error.

* Visible and invisible functions

In an R package, the typical user will only expect to be able to access
your top-level function. The functions this in turns call should be
hidden. You do this by prepending a period. I've done this in your
code. This is also important because every non-hidden function
requires a .Rd file in a R package.

--- I was even unaware that .function makes a function invisible :
I will stick to this.
